import{_ as s,c as i,o as a,V as n}from"./chunks/framework.--NMbU3Q.js";const y=JSON.parse('{"title":"本章概要","description":"","frontmatter":{},"headers":[],"relativePath":"JavaScript/一文搞定闭包this指向.md","filePath":"JavaScript/一文搞定闭包this指向.md"}'),l={name:"JavaScript/一文搞定闭包this指向.md"},h=n(`<h1 id="本章概要" tabindex="-1">本章概要 <a class="header-anchor" href="#本章概要" aria-label="Permalink to &quot;本章概要&quot;">​</a></h1><p>本来只想讲闭包,但是要把闭包真的弄清楚.牵扯的东西比较多,所以想放在一起.通过本章,你将会弄明白 <strong>作用域</strong> <strong>作用域链</strong> <strong>词法作用域</strong> <strong>执行上下文</strong> <strong>this指向</strong> <strong>闭包</strong> 等js基础知识</p><h2 id="作用域和作用域链" tabindex="-1">作用域和作用域链 <a class="header-anchor" href="#作用域和作用域链" aria-label="Permalink to &quot;作用域和作用域链&quot;">​</a></h2><p><strong>作用域的概念</strong></p><blockquote><p>作用域查就是变量的规则,相当于将变量包裹,隔离起来.域外不能访问域内.</p></blockquote><p><strong>js中有哪些作用域</strong></p><ol><li>全局作用域</li><li>函数作用域</li><li>块级作用域(Es6新增)</li></ol><p><strong>作用域链</strong></p><p>多个作用域嵌套后,就有层级结构.如果在当前作用域不能找到变量,就会沿着外层作用域一直往外找,直到找到最外层.这种类似链条的关系就是我理解的作用域链.</p><p><strong>变量提升</strong></p><p>在a,b声明前打印a,b结果如下</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b,a) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// f b(){} undefined</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ji&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span></code></pre></div><ol><li>var声明的变量以及非表达式声明的函数,编译器会在当前作用域顶部,创建同名变量</li><li>函数赋值为与变量同名的空函数体,否则为undefined</li><li>函数与变量同名, 函数优先级高</li><li>如果重复声明,后者覆盖前者</li></ol><p><strong>执行阶段</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//Uncaught ReferenceError: c is not defined</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// console.log(c)  // 2</span></span></code></pre></div><p>运行上面的代码,报错 Uncaught ReferenceError.注释掉函数内部打印,在外面打印又是2,为什么?这是时候要引出两个概念?<strong>LHS</strong> <strong>RHS</strong> 等号右边,取值可以称之为RHS, 赋值操作称之为LHS</p><h2 id="变量查找的武器" tabindex="-1">变量查找的武器 <a class="header-anchor" href="#变量查找的武器" aria-label="Permalink to &quot;变量查找的武器&quot;">​</a></h2><ul><li>RHS 沿着作用域链往上查找,如果最外层没有找到,报错Uncaught ReferenceError</li><li>LHS 沿着作用域链往上查找,如果最外层没有找到,会在最外层创建一个同名变量并赋值</li></ul><p>了解以上知识,我们也许会思考一个问题.函数的作用域到底是执行的时候确定的呢还是声明的时候确定呢? 答案是声明的时候,就已经确定了.因为js的作用域是基于词法作用域.</p><h2 id="词法作用域" tabindex="-1">词法作用域 <a class="header-anchor" href="#词法作用域" aria-label="Permalink to &quot;词法作用域&quot;">​</a></h2><p>比如说,我在一个函数内部抛出一个函数,在全局又接收了这个函数并运行.此时执行函数的作用域是全局还是依然在他声明的地方. 此时,词法作用域的作用就出来了.作用域的层级关系是静态的.在声明的时候,就已经确定了.取决于代码的位置,不是执行的位置. 这就是我理解的词法作用域</p><h2 id="js代码是如何执行的" tabindex="-1">js代码是如何执行的 <a class="header-anchor" href="#js代码是如何执行的" aria-label="Permalink to &quot;js代码是如何执行的&quot;">​</a></h2><p><strong>准备工作</strong></p><p>当要执行一段js脚本的时候,js引擎会提供一个栈结构的东西,保证js的代码从上到下有序执行.这个栈就是 <strong>调用栈</strong> 还会为js脚本提供一个叫做 <strong>全局上下文</strong> 的东西.并把全局上下文压入栈底. 并在全局上下文上创建global对象,用来存储全局的变量. global对象指向window.简单总结如下:</p><ol><li>创建全局上下文</li><li>创建global对象指向window</li><li>压入栈底</li></ol><h2 id="执行上下文" tabindex="-1">执行上下文 <a class="header-anchor" href="#执行上下文" aria-label="Permalink to &quot;执行上下文&quot;">​</a></h2><p>上面已经对 <strong>全局上下文</strong> 简单的介绍,保存js代码在执行时需要用的信息一种抽象概念.除了全局上下文,还有 <strong>函数上下文</strong>, <strong>eval上下文</strong>.eval上下文可忽略,官方并不推荐使用.</p><p><strong>函数上下文</strong></p><p>执行函数前准备阶段.</p><ol><li>绑定this</li><li>创建变量对象VO,存储函数内部的变量</li><li>确定作用域链</li></ol><p>执行函数</p><ol><li>将函数上下文入栈</li><li>如果内部还有函数执行,将内部函数入栈,递归</li><li>栈内从顶部依次执行出栈</li><li>直到调用栈为空,整个js脚本执行结束</li></ol><h2 id="探索闭包" tabindex="-1">探索闭包 <a class="header-anchor" href="#探索闭包" aria-label="Permalink to &quot;探索闭包&quot;">​</a></h2><p>前面讲了 <strong>作用域链</strong> <strong>简单的编译过程</strong> <strong>函数执行上下文</strong> <strong>调用栈</strong> 这么多东西,其实就是为了闭包做铺垫.这也是笔者在探索闭包的过程中,看了大量的文章,也参阅了一些经典的js书籍,其实大部分讲的还是概览,并未揭露本质.先从最简单的🌰开始:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;t&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inner</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerFn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">innerFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>显而易见inner引用了out中b,调用innerFn()的时候,在innerFn的作用域链上,多了一个Closuer(out),产生了闭包</p><p><strong>思考</strong></p><p>1.不调用innerFn()会产生闭包吗?只执行out</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;t&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inner</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>2.不抛出inner会产生吗?</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;t&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>有以上两个疑问,因为在调试的时候,inner没有调用,在调用堆栈中一直找不到Clouser.后来才明白,闭包存在于内部函数的作用域链中.内部函数调用,我们在控制台能显示的看的到闭包.那如果内部函数没调用呢?回到起点逆向分析:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;t&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inner</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerFn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">innerFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>out()函数执行完,out执行上下文已经出栈了,out中b也随着上下文清楚了.但我们再次调用inneFn()的时候,依然能拿到b.说明此时内部的变量b不是真正的外部函数的b.造成这种现象的原因是什么呢?经过笔者不停的查阅资料,跟 <strong>V8预编译</strong> <strong>V8惰性解析</strong> 有关.有兴趣的同学可以查看详细的资料,这里只做简单的介绍.</p><p><strong>V8惰性解析</strong> 为了节约内存,遇到函数的时候,并不会真正的解析它.比如 funtion a(){...},会以 a = f a(){}的形式保存在作用域中.只有真正调用的时候,才会去赋值操作.但是,有一种特殊情况,闭包.那么V8又是怎么处理闭包的呢?</p><p><strong>V8预解析</strong> 当执行一个函数的时候,如果函数内部还有函数的话,V8会对这个函数进行预解析.扫描这个函数内部是否引用了外层函数的变量.如果引用了,就把该变量捕获到内存中去.就形成了闭包</p><p>所以闭包是什么呢?当调用一个函数的时候,如果内部函数引用外部函数变量,编译器预解析,就会产生闭包.</p><h2 id="什么是this" tabindex="-1">什么是this <a class="header-anchor" href="#什么是this" aria-label="Permalink to &quot;什么是this&quot;">​</a></h2><p>前面已经讲到,当调用函数的时候,会先创建函数上下文,并给上下文绑定一个this对象.因此,this就是函数上下文上的一个属性.那么this的值如何确定呢?</p><h2 id="绑定this的规则" tabindex="-1">绑定this的规则 <a class="header-anchor" href="#绑定this的规则" aria-label="Permalink to &quot;绑定this的规则&quot;">​</a></h2><p>1.默认绑定</p><p>直接调用的话,默认绑定到全局对象window</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>2.隐士绑定</p><ul><li>由一个对象去调用,this绑定到该对象</li><li>隐士链式调用</li><li>隐士丢失</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.a) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4 隐士链式调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.a) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//  2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    obj2: ojb2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2 隐士调用 调用函数的位置 this obj</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.obj2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用函数 的位置  this obj2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3 隐士调用丢失  调用函数的位置 window</span></span></code></pre></div><p><strong>总结</strong>: 不管如何调用,要找到函数调用的位置,因为this是在调用的时候绑定的.找到调用的位置,找到最后一个调用者.</p><p>3.显示绑定</p><p>通过call,bind,apply函数改变this的指向,参考<a href="./手写call|bind|apply.html">call内部实现原理</a></p><p>4.new绑定</p><p>下一节会详细介绍new的内部实现</p><p><strong>优先级</strong>:new &gt; 显示绑定 &gt; 隐士绑定 &gt; 默认绑定</p><h2 id="new内部实现原理" tabindex="-1">new内部实现原理 <a class="header-anchor" href="#new内部实现原理" aria-label="Permalink to &quot;new内部实现原理&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myNew</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 创建一个空对象 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 对象的原型指向构造函数的原型 ojb就能访问Fun原型上的属性和方法了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   obj.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   //绑定this</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fun.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">args)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   //处理返回值 不是对象就返回obj</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>本文设计到的知识点有: <strong>作用域</strong> <strong>作用域链</strong> <strong>变量提升</strong> <strong>LHS</strong> <strong>RHS</strong> <strong>闭包</strong> <strong>执行上下文</strong> <strong>this指向</strong> <strong>new内部原理</strong></p><ol><li>闭包是编译器预编译导致的</li><li>this是调用函数时候确定的,所以,调用位置+调用对象确定this.</li></ol>`,67),t=[h];function p(k,e,r,E,g,d){return a(),i("div",null,t)}const c=s(l,[["render",p]]);export{y as __pageData,c as default};
