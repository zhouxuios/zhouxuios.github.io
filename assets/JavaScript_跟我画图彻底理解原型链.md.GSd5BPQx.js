import{_ as s,c as i,o as a,V as t}from"./chunks/framework.--NMbU3Q.js";const n="/assets/yxl01.wfrOZI8i.jpg",h="/assets/yxl02.KHmMGugQ.jpg",p="/assets/yxl03.EtHdZf6f.jpg",l="/assets/yxl04.Owe2MH13.jpg",e="/assets/yxl05.4zmSFs9E.jpg",k="/assets/yxl06.LWnyE80i.jpg",b=JSON.parse('{"title":"原型和原型链","description":"","frontmatter":{},"headers":[],"relativePath":"JavaScript/跟我画图彻底理解原型链.md","filePath":"JavaScript/跟我画图彻底理解原型链.md"}'),o={name:"JavaScript/跟我画图彻底理解原型链.md"},r=t(`<h1 id="原型和原型链" tabindex="-1">原型和原型链 <a class="header-anchor" href="#原型和原型链" aria-label="Permalink to &quot;原型和原型链&quot;">​</a></h1><h2 id="前提" tabindex="-1">前提 <a class="header-anchor" href="#前提" aria-label="Permalink to &quot;前提&quot;">​</a></h2><p>要向彻底理解原型链,先要理解什么是原型?</p><h2 id="原型or原型对象" tabindex="-1">原型or原型对象 <a class="header-anchor" href="#原型or原型对象" aria-label="Permalink to &quot;原型or原型对象&quot;">​</a></h2><ol><li>函数才有原型,原型也叫原型对象.</li><li>当声明一个函数的时候,系统就会在内存中创建一个对象,就是这个函数的原型对象.</li><li>函数通过prototype指向原型对象.实例通过__proto__指向原型对象.</li></ol><p>例如,我们创建一个Foo函数,并创建一个foo对象</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">funtion </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// {constuctor: f Foo()}</span></span></code></pre></div><p>打印结果,可以得知 Foo.prototype和foo.__proto__都指向同一个地址,并且这个地址存了一个对象,这个对象就是Foo的原型对象.三者的关系如图1所示: <img src="`+n+`" alt="图1"></p><h2 id="引出原型链" tabindex="-1">引出原型链 <a class="header-anchor" href="#引出原型链" aria-label="Permalink to &quot;引出原型链&quot;">​</a></h2><p>实例通过__proto__指向它的原型,foo.__proto__指向Foo的原型对象?.而Foo的原型对象也是一个对象,它的__proto__指向哪里?多往上查找几级呢?</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// {constuctor: f Object(),toString: f....}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// null</span></span></code></pre></div><p>我们会发现Foo原型的原型是 Object的原型,Object的原型对象是null.null就是原型链的终点. 于是,图1可以延伸至图2: <img src="`+h+'" alt="图2"></p><p>由上图可明显的看出,foo-&gt;Foo原型对象-&gt;Object原型对象-&gt;null,通过__proto__连接,形成一条链条.就是我们所说的原型链.当我们查找一个对象的方法或属性时,如果该对象本身没有,就会沿着原型链向上查找.直到原型链的终点null. 例如: Object的原型对象上有toString方法.因为原型链,我们foo也可以调用toString.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[object Object]</span></span></code></pre></div><h2 id="扩充原型链" tabindex="-1">扩充原型链 <a class="header-anchor" href="#扩充原型链" aria-label="Permalink to &quot;扩充原型链&quot;">​</a></h2><p>图2中,Object原型对象是由Object函数而来,完善图2 <img src="'+p+`" alt="图3"></p><p>图3中,Foo函数和Object函数因何而来? javascript万物皆对象,函数也是对象.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Foo.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// f () {[native code]} </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// f () {[native code]}</span></span></code></pre></div><p>可以发现,Object函数和Foo函数的原型是同一个东西.哥儿俩是同一个东西构造的.</p><h2 id="function函数" tabindex="-1">Function函数 <a class="header-anchor" href="#function函数" aria-label="Permalink to &quot;Function函数&quot;">​</a></h2><p>打印Object函数的原型对象的构造函数</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ƒ Function() { [native code] }</span></span></code></pre></div><p>Object函数和Foo函数是由Funtion函数构造的.由此可以推导出, 函数是由Funtion函数构造的,函数本身的__proto__都指向Funtion的原型对象. 完善原型链如图4: <img src="`+l+'" alt="图4"></p><p>Function原型对象也是一个对象,指向谁呢?</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Funtion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// {constuctor: f Object()...}</span></span></code></pre></div><p>Funtion原型对象指向Object原型对象 完善原型链如图5: <img src="'+e+'" alt="图5"></p><h2 id="原型链闭环" tabindex="-1">原型链闭环 <a class="header-anchor" href="#原型链闭环" aria-label="Permalink to &quot;原型链闭环&quot;">​</a></h2><p>到了这一步,我们发现,就差Funtion函数这哥们儿了.函数也是对象,那Funtion函数__proto__是啥呢?</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Function.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ƒ () { [native code] }</span></span></code></pre></div><p>可以得出结论,Function函数的__proto__还是指向Function的原型对象.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Funtion.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Funtion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre></div><p>自此,原型链形成了闭环</p><p><img src="'+k+'" alt="图6"></p>',33),d=[r];function E(c,g,_,y,F,u){return a(),i("div",null,d)}const v=s(o,[["render",E]]);export{b as __pageData,v as default};
