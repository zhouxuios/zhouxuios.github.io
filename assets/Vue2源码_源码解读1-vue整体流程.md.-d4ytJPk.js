import{_ as e,c as i,o as t,V as a}from"./chunks/framework.--NMbU3Q.js";const l="/assets/vue01_lifecycle.Ve1DcpO2.png",v=JSON.parse('{"title":"整体流程","description":"","frontmatter":{},"headers":[],"relativePath":"Vue2源码/源码解读1-vue整体流程.md","filePath":"Vue2源码/源码解读1-vue整体流程.md"}'),o={name:"Vue2源码/源码解读1-vue整体流程.md"},r=a('<h1 id="整体流程" tabindex="-1">整体流程 <a class="header-anchor" href="#整体流程" aria-label="Permalink to &quot;整体流程&quot;">​</a></h1><p>通过本文,我们将对Vue实例化过程,进行梳理.流程走完,对Vue的主要流程,以及重要节点是干什么有一个初步的认识.</p><h2 id="准备阶段" tabindex="-1">准备阶段 <a class="header-anchor" href="#准备阶段" aria-label="Permalink to &quot;准备阶段&quot;">​</a></h2><p>Vue构造函数和原型对象加东西,为后续做准备工作</p><ul><li>initGlobalAPI(Vue)</li><li>initMixin(Vue)</li><li>stateMixin(Vue)</li><li>eventsMixin(Vue)</li><li>lifecycleMixin(Vue)</li><li>renderMixin(Vue)</li></ul><h2 id="初始化阶段" tabindex="-1">初始化阶段 <a class="header-anchor" href="#初始化阶段" aria-label="Permalink to &quot;初始化阶段&quot;">​</a></h2><p>初始化的工作都是放在_init(options)方法</p><ol><li>mergeOptions <blockquote><p>合并选项用户传入的options和Vue.options进行合并</p></blockquote></li><li>initLifecycle(vm)</li><li>initEvents(vm)</li><li>initRender(vm)</li><li>callHook(vm, &#39;beforeCreate&#39;)</li><li>initInjections(vm)</li><li>initState(vm) <blockquote><p>初始化props,data,method,watch,computed 数据会变成响应式</p></blockquote></li><li>initProvide(vm)</li><li>callHook(vm, &#39;created&#39;)</li></ol><p>created勾子函数执行后,data,method,computed,watch,render等数据都已经准备好了</p><h2 id="挂载前" tabindex="-1">挂载前 <a class="header-anchor" href="#挂载前" aria-label="Permalink to &quot;挂载前&quot;">​</a></h2><p>目的是拿到render函数</p><ol><li>如果options有render,直接用</li><li>没有render,拿template.将template编译成render函数</li><li>没有模版,将el.outerHtml作为template,编译成render函数</li><li>调用beforeMount勾子</li></ol><h2 id="挂载" tabindex="-1">挂载 <a class="header-anchor" href="#挂载" aria-label="Permalink to &quot;挂载&quot;">​</a></h2><ol><li>updateComponent(),更新组件 <blockquote><p>内部调用vm._update(vm._render(), hydrating)函数, vm._render将render函数转换成vnode render到vnode完成依赖收集 vm._update将vnode转换成真实dom</p></blockquote></li><li>实例化渲染watcher,updateComponent交给渲染watcher,实现数据驱动,响应式.</li></ol><h2 id="流程图" tabindex="-1">流程图 <a class="header-anchor" href="#流程图" aria-label="Permalink to &quot;流程图&quot;">​</a></h2><p><img src="'+l+'" alt="lifecycle"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>梳理完流程,结合官方的图示,豁然开朗,原来路一直都在脚下.</p>',18),n=[r];function d(c,u,p,s,h,_){return t(),i("div",null,n)}const b=e(o,[["render",d]]);export{v as __pageData,b as default};
